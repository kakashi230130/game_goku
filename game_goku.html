<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Dragon Ball Style Fighter - Phase 1</title>

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        #loading-screen {
            position: absolute;
            inset: 0;
            background: #000;
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            z-index: 999;
            transition: opacity 0.5s ease;
        }
    </style>
</head>
<body>

<div id="loading-screen">Loading Assets...</div>

<script type="importmap">
{
    "imports": {
        "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
    }
}
</script>

<script type="module">
import * as THREE from 'three';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { FBXLoader } from 'three/addons/loaders/FBXLoader.js';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

/* =====================================================
   CONFIG
===================================================== */
const ASSETS = {
    arena: 'https://raw.githubusercontent.com/kakashi230130/game_goku/main/old_fighting_stage.glb',
    goku:  'https://raw.githubusercontent.com/kakashi230130/game_goku/main/goku.fbx',
    mabu:  'https://raw.githubusercontent.com/kakashi230130/game_goku/main/mabu.fbx'
};

let scene, camera, renderer, clock, controls;
const mixers = [];
const fighters = {};
let GROUND_Y = 0;
const keys = {};
const GOKU_SPEED = 5.0;
const GOKU_TURN_SPEED = 10.0;

const GOKU_STATE = {
    IDLE: 'idle',
    MOVING: 'moving',
    ATTACKING: 'attacking'
};

let gokuState = GOKU_STATE.IDLE;
let currentGokuAction = null;

// Keyboard Listeners
window.addEventListener('keydown', (e) => { keys[e.code] = true; handleAttackInput(e.code); });
window.addEventListener('keyup', (e) => { keys[e.code] = false; });


/* =====================================================
   INIT
===================================================== */
init();

function init() {
    scene = new THREE.Scene();

    // ðŸŒ¤ï¸ Dragon Ball style sky
    scene.background = new THREE.Color(0x87CEEB);
    scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

    camera = new THREE.PerspectiveCamera(
        50,
        window.innerWidth / window.innerHeight,
        0.1,
        100
    );
    camera.position.set(0, 8, 16);
    camera.lookAt(0, 2, 0);

    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.shadowMap.enabled = true;
    renderer.shadowMap.type = THREE.PCFSoftShadowMap;
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.85;
    document.body.appendChild(renderer.domElement);

    clock = new THREE.Clock();

    controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 2, 0);
    controls.enablePan = false;
    controls.enableDamping = true;
    controls.minAzimuthAngle = -Math.PI / 6;
    controls.maxAzimuthAngle =  Math.PI / 6;
    controls.maxPolarAngle = Math.PI / 2 - 0.1;

    setupLights();
    loadAssets();

    window.addEventListener('resize', onWindowResize);
}

/* =====================================================
   LIGHTING
===================================================== */
function setupLights() {
    // Reduced AmbientLight for better shadow contrast
    scene.add(new THREE.AmbientLight(0xffffff, 0.4)); 

    // Increased Key Light intensity for facial detail
    const key = new THREE.DirectionalLight(0xffffff, 2.2);
    key.position.set(5, 10, 10);
    key.castShadow = true;
    scene.add(key);

    const fill = new THREE.DirectionalLight(0xaaccff, 1.2);
    fill.position.set(-8, 5, 10);
    scene.add(fill);

    // Rim light to separate character from background
    const rim = new THREE.SpotLight(0x88aaff, 3.0);
    rim.position.set(0, 8, -10);
    scene.add(rim);
}

/* =====================================================
   LOAD ASSETS
===================================================== */
function loadAssets() {
    const manager = new THREE.LoadingManager(() => {
        const loading = document.getElementById('loading-screen');
        loading.style.opacity = 0;
        setTimeout(() => loading.remove(), 500);
        animate();
    });

    const gltfLoader = new GLTFLoader(manager);
    const fbxLoader  = new FBXLoader(manager);

    // Arena váº«n dÃ¹ng GLB
    loadArena(gltfLoader, ASSETS.arena);

    // Fighters dÃ¹ng FBX
    loadFighterFBX(fbxLoader, ASSETS.goku, {
        name: 'Goku',
        position: new THREE.Vector3(-3, 0, 0),
        targetHeight: 3.6
    });

    loadFighterFBX(fbxLoader, ASSETS.mabu, {
        name: 'Buu',
        position: new THREE.Vector3(3, 0, 0),
        targetHeight: 4.0
    });
}

function loadFighterFBX(loader, url, cfg) {
    loader.load(url, object => {
        const model = object;

        /* =============================
           TRANSFORM CÆ  Báº¢N
        ============================== */
        model.position.copy(cfg.position);
        model.rotation.set(0, Math.PI, 0);

        // âŒ KHÃ”NG Ã©p scale 0.01 ná»¯a
        model.scale.set(1, 1, 1);
        model.traverse(c => {
            if (c.isMesh) {
                console.log(
                    c.name,
                    c.material.map ? 'HAS TEXTURE' : 'NO TEXTURE'
                );
            }
        });

        scene.add(model);

        /* =============================
           SCALE THEO CHIá»€U CAO THá»°C
        ============================== */
        model.updateMatrixWorld(true);
        const box = new THREE.Box3().setFromObject(model);
        const size = new THREE.Vector3();
        box.getSize(size);

        const scaleFactor = cfg.targetHeight / size.y;
        model.scale.multiplyScalar(scaleFactor);

        /* =============================
           FIX MATERIAL (Cá»°C Ká»² QUAN TRá»ŒNG)
        ============================== */
        model.traverse(child => {
            if (!child.isMesh) return;

            child.castShadow = true;
            child.receiveShadow = true;

            // ðŸ‘‰ Ã‰P TOÃ€N Bá»˜ sang MeshStandardMaterial
            const oldMat = child.material;
            const mat = new THREE.MeshStandardMaterial({
                color: oldMat.color || new THREE.Color(0xffffff),
                roughness: 0.6,
                metalness: 0.0
            });

            if (oldMat.map && oldMat.map.image) {
                mat.map = oldMat.map;
                mat.map.colorSpace = THREE.SRGBColorSpace;
            }

            mat.skinning = true;
            child.material = mat;

            child.geometry.computeVertexNormals();
        });

        /* =============================
           GROUND (CHá»ˆ KHI CÃ“ ARENA)
        ============================== */
        if (GROUND_Y !== null) {
            groundCharacter(model);
        }

        /* =============================
           ANIMATION
        ============================== */
        const mixer = new THREE.AnimationMixer(model);
        mixers.push(mixer);

        const actions = {};
        object.animations.forEach(clip => {
            const action = mixer.clipAction(clip);
            const name = clip.name.toLowerCase();

            if (name.includes('idle') || name.includes('step')) {
                action.loop = THREE.LoopRepeat;
            } else {
                action.loop = THREE.LoopOnce;
                action.clampWhenFinished = true;
            }

            actions[clip.name] = action;
        });

        fighters[cfg.name] = {
            mesh: model,
            mixer,
            actions,
            config: cfg
        };

        /* =============================
           PLAY IDLE
        ============================== */
        const idle = Object.keys(actions).find(n => n.toLowerCase().includes('idle'));
        if (idle) {
            actions[idle].play();
            if (cfg.name === 'Goku') currentGokuAction = actions[idle];
        }

        /* =============================
           ATTACK END
        ============================== */
        if (cfg.name === 'Goku') {
            mixer.addEventListener('finished', () => {
                if (gokuState === GOKU_STATE.ATTACKING) {
                    setStateGoku(GOKU_STATE.IDLE);
                }
            });
        }
    });
}


/* =====================================================
   ARENA + GROUND DETECTION
===================================================== */
function loadArena(loader, url) {
    loader.load(url, gltf => {
        const arena = gltf.scene;
        arena.position.set(0, 0, 0);
        const ARENA_SCALE = 80; // ðŸ‘ˆ PHÃ“NG TO ARENA (6â€“10 lÃ  Ä‘áº¹p)

        arena.scale.set(
            ARENA_SCALE,
            ARENA_SCALE,
            ARENA_SCALE
        );

        arena.traverse(m => {
            if (m.isMesh) m.receiveShadow = true;
        });

        scene.add(arena);
        arena.updateMatrixWorld(true);

        let floorMesh = null;
        let maxArea = 0;

        arena.traverse(child => {
            if (!child.isMesh) return;
            const box = new THREE.Box3().setFromObject(child);
            const size = new THREE.Vector3();
            box.getSize(size);
            const area = size.x * size.z;
            if (area > maxArea) {
                maxArea = area;
                floorMesh = child;
            }
        });

        if (floorMesh) {
            const floorBox = new THREE.Box3().setFromObject(floorMesh);
            GROUND_Y = floorBox.max.y;

        }

        Object.values(fighters).forEach(f => groundCharacter(f.mesh));
    });
}

/* =====================================================
   CHARACTER
===================================================== */

function setStateGoku(newState, animName = 'idle') {
    if (gokuState === newState && currentGokuAction?._clip.name === animName) return;

    const goku = fighters['Goku'];
    if (!goku) return;

    // Determine the next animation clip
    let nextAction = goku.actions[animName];
    
    // Fallback logic for missing clips
    if (!nextAction) {
        console.warn(`Animation missing: ${animName}. Falling back to idle.`);
        nextAction = goku.actions[Object.keys(goku.actions).find(n => n.toLowerCase().includes('idle'))];
    }

    if (currentGokuAction !== nextAction) {
        console.log(`Switching to: ${nextAction._clip.name}`);
        nextAction.reset().fadeIn(0.2).play();
        if (currentGokuAction) currentGokuAction.fadeOut(0.2);
        currentGokuAction = nextAction;
    }

    gokuState = newState;
}

function updateGoku(delta) {
    const goku = fighters['Goku'];
    if (!goku || gokuState === GOKU_STATE.ATTACKING) return;

    const moveVec = new THREE.Vector3();
    let animName = Object.keys(goku.actions).find(n => n.toLowerCase().includes('idle'));
    let isMoving = false;

    if (keys['KeyW']) {
        moveVec.z -= 1;
        animName = 'step_forward';
        isMoving = true;
    } else if (keys['KeyS']) {
        moveVec.z += 1;
        animName = 'step_back';
        isMoving = true;
    } else if (keys['KeyA']) {
        moveVec.x -= 1;
        animName = 'left_step';
        isMoving = true;
    } else if (keys['KeyD']) {
        moveVec.x += 1;
        animName = 'right_step';
        isMoving = true;
    }

    if (isMoving) {
        moveVec.normalize();
        goku.mesh.position.addScaledVector(moveVec, GOKU_SPEED * delta);

        // âœ… XOAY ÄÃšNG THEO HÆ¯á»šNG DI CHUYá»‚N (CHUáº¨N FIGHTING GAME)
        const angle = Math.atan2(moveVec.x, moveVec.z);
        goku.mesh.rotation.y = angle;

        setStateGoku(GOKU_STATE.MOVING, animName);
    } else {
        setStateGoku(
            GOKU_STATE.IDLE,
            Object.keys(goku.actions).find(n => n.toLowerCase().includes('idle'))
        );
    }

    // === Always stay on ground ===
    groundCharacter(goku.mesh);
}

function handleAttackInput(code) {
    if (gokuState === GOKU_STATE.ATTACKING || !fighters['Goku']) return;

    const goku = fighters['Goku'];
    let attackClip = null;

    switch(code) {
        case 'KeyJ': attackClip = 'goku_left_boxing'; break;
        case 'KeyK': attackClip = 'goku_right_boxing'; break;
        case 'KeyU': attackClip = 'goku_left_kick'; break;
        case 'KeyI': attackClip = 'goku_right_kick'; break;
        case 'KeyL': attackClip = 'goku_combo'; break;
    }

    if (attackClip && goku.actions[attackClip]) {
        gokuState = GOKU_STATE.ATTACKING;
        if (currentGokuAction) currentGokuAction.fadeOut(0.15);
        
        const action = goku.actions[attackClip];
        action.reset().fadeIn(0.15).play();
        currentGokuAction = action;
    }
}

function groundCharacter(mesh) {
    if (!mesh || GROUND_Y === null) return;

    mesh.updateMatrixWorld(true);
    const box = new THREE.Box3().setFromObject(mesh);
    const offset = GROUND_Y - box.min.y;
    mesh.position.y += offset;

    // ðŸ”’ LOCK trá»¥c Ä‘á»ƒ trÃ¡nh náº±m/ngÃ£
    mesh.rotation.x = 0;
    mesh.rotation.z = 0;
}

// Update the animate loop:
function animate() {
    requestAnimationFrame(animate);
    const delta = clock.getDelta();
    
    updateGoku(delta); // Process Phase 2 Movement
    
    mixers.forEach(m => m.update(delta));
    controls.update();
    renderer.render(scene, camera);
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
</script>

</body>
</html>
